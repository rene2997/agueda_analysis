# fuzzer/coverage_tracker.py (modified to interface with Java instrumentation)
from typing import Set, Optional, Dict, Tuple
import json
import os
import csv

class CoverageTracker:
    def __init__(self, config):
        self.covered_branches: Set[str] = set()  # Stores covered branches (branch IDs output by Java instrumentation)
        self.config = config

        # Use a set to store the IDs of all covered edges for efficient lookup
        self.covered_edges = set()
        self.total_covered_count = 0  # Can be used to count the cumulative number of covered edges

        # Initialize a global coverage bitmap, using bytearray is more efficient
        # The initial value of all positions is 0
        self.global_coverage_map = bytearray(self.config.coverage_map_size)

        # AFL-style hit count classification table. Maps raw counts to representative "buckets".
        # 0 -> 0, 1 -> 1, 2 -> 2, 3 -> 3, 4-7 -> 4, 8-15 -> 5, 16-31 -> 6, 32-127 -> 7, 128+ -> 8
        self.hit_count_buckets = self._initialize_buckets()

    def _initialize_buckets(self):
        """Pre-calculate the corresponding bucket for each count from 0-255 to avoid repeated calculations"""
        buckets = bytearray(256)
        for i in range(256):
            if i == 0:
                buckets[i] = 0
            elif i == 1:
                buckets[i] = 1
            elif i == 2:
                buckets[i] = 2
            elif i == 3:
                buckets[i] = 3
            elif i < 8:
                buckets[i] = 4
            elif i < 16:
                buckets[i] = 5
            elif i < 32:
                buckets[i] = 6
            elif i < 128:
                buckets[i] = 7
            else:
                buckets[i] = 8
        return buckets

    def track_execution(self, java_runner, new_input):
        """
        Execute, read the coverage bitmap, and determine if there is new coverage.
        """
        # 1. Execute the Java program
        error_msg = java_runner.run_java_program(new_input)

        # 2. Read the coverage bitmap generated by this run (bytescribe.cov)
        bitmap_file = self.config.coverage_output_path
        try:
            with open(bitmap_file, 'rb') as f:
                current_run_map = bytearray(f.read())
        except FileNotFoundError:
            # If the bitmap file does not exist, it means the execution failed and there is no new coverage
            return False, error_msg

        # 3. Compare the bitmaps to determine if there is new behavior (core logic)
        has_new_coverage = False
        for i in range(self.config.coverage_map_size):
            # If the hit count of the current run is not 0
            if current_run_map[i] != 0:
                # Put both the current hit count and the global hit count into "buckets"
                current_bucket = self.hit_count_buckets[current_run_map[i]]
                global_bucket = self.hit_count_buckets[self.global_coverage_map[i]]

                # If the current "bucket" is larger than the global "bucket", it means new behavior has been discovered
                # For example, if it was hit only once before (bucket 1), and now it is hit 5 times (bucket 4), this is a valuable discovery
                if current_bucket > global_bucket:
                    has_new_coverage = True
                    # Update the global bitmap to record this more valuable hit count
                    self.global_coverage_map[i] = current_run_map[i]

        # 4. Return the result
        is_error = bool(error_msg and "Exception" in error_msg)
        return has_new_coverage, error_msg if is_error else None

    def get_coverage_stats(self) -> Dict:
        """Returns coverage statistics"""
        return {
            "total_covered_branches": len(self.covered_branches),
            "coverage_detail": list(self.covered_branches)
        }

    def get_coverage_stats2(self):
        """Calculates the total number of covered edges"""
        # Count the number of non-zero items in the global bitmap, which is the total number of covered edges
        total_covered_edges = sum(1 for byte in self.global_coverage_map if byte > 0)
        return {
            "total_covered_branches": total_covered_edges
        }

    def reset(self):
        """Resets the coverage (used when re-execution is required)"""
        self.covered_branches.clear()